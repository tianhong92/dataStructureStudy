# 数据结构算法学习
包含了平时数据结构学习和写的算法题
## 自己实现的数据结构类
见DIYDataStructure目录
* Array
      
      数组删除引用类型元素会产生loitering objects, 但不等于memory leak
      动态数组resize会导致时间复杂度增加， 但是不是每次都触发resize， 可以
      用均摊复杂度分析。 但是还是要防止复杂度震荡。  缩容采取Lazy的方式。
      
* Stack

      撤销操作
      程序调用的系统栈
      括号匹配
      ArrayStack和LinkedListStack的时间复杂度都是O(1)。 两者效率很难比较， 原因是：
      数组栈时不时要resize
      数据量大的时候链表栈要经常new空间， 所以效率不一定比数组栈高
      
* Queue
     
       数组队列dequeue复杂度为O(n)，取出队头元素，后面元素都要向前移动。
       可以使用循环队列解决这个问题(移动front 和 tail指针， fornt == tail队列为空，
       (front + 1)%capacity = tail队列满了， 浪费一个队列空间)    

       链表实现队列， 利用改进的链表， 增加一个tail提高效率， 队首head删除元素， 队尾tail添加元素
* List
    
       真正的动态数据结构，  
       给链表头添加元素和给其他位置添加不一样， 因为不用找到头一个元素。
       为了和给其他位置加元素统一起来， 可以设立虚拟头结点（dummy head）， 头结点不存元素。
       头结点为dummyhead.next
       只对链表头进行操作： O(1)， 所以可以用链表来实现栈

* 二分搜索树

       局限性： 存储的节点必须有可比较性，
       使用递归插入元素时候， 如果add函数有返回值Node， 则在外面调用时候不用考虑根节点为空的情况。
       不然先要保证根节点不为空（调用之前先判断一下）， 否则会丢失根节点指针！！！

       后续遍历： 应用在内存释放
       前中后续遍历本质上都是：深度优先
       二分搜索树层续遍历： 广度优先， 队列实现， 可能会更有效的访问到想要的对象。常用于算法设计的无权图最短路径

### 使用泛型
* 让数据结构能放置“任何”数据类型
* 不可以是基本数据类型， 只能是类对象
* 每个基本数据类型都有对应的包装类（wrapper class）
* 基本数据类型和包装类可以自动装换， 自动加包， 解包    
           
## 联系作者
406507715@qq.com / tianhong229@gmail.com